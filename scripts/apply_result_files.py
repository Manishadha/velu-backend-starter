#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import os
import shutil
import sqlite3
import sys
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

REPO_ROOT = Path(__file__).resolve().parents[1]


def _safe_rel_path(p: str) -> Path:
    rel = Path(p)
    if rel.is_absolute():
        raise ValueError(f"absolute paths not allowed: {p}")
    norm = Path(os.path.normpath(str(rel)))
    if str(norm).startswith(".."):
        raise ValueError(f"path escapes repo: {p}")
    return norm


def _iter_results(obj: Any) -> Iterable[Dict[str, Any]]:
    if isinstance(obj, dict):
        # common wrappers
        if "item" in obj and isinstance(obj["item"], dict):
            # /results/<id>?expand=1 shape
            it = obj["item"]
            if isinstance(it.get("result"), dict):
                yield it["result"]
                return
        if "result" in obj and isinstance(obj["result"], dict):
            yield obj["result"]
            return
        if "results" in obj and isinstance(obj["results"], list):
            for item in obj["results"]:
                if isinstance(item, dict):
                    yield item
            return
        yield obj
        return

    if isinstance(obj, list):
        for item in obj:
            if isinstance(item, dict):
                yield item


def _extract_files_list(result: Dict[str, Any]) -> List[Dict[str, str]]:
    files = result.get("files")
    if not isinstance(files, list):
        return []
    out: List[Dict[str, str]] = []
    for f in files:
        if not isinstance(f, dict):
            continue
        path = f.get("path")
        content = f.get("content")
        if isinstance(path, str) and isinstance(content, str):
            out.append({"path": path, "content": content})
    return out


def _extract_wrote_list(result: Dict[str, Any]) -> List[str]:
    wrote = result.get("wrote")
    if not isinstance(wrote, list):
        return []
    out: List[str] = []
    for p in wrote:
        if isinstance(p, str) and p.strip():
            out.append(p.strip())
    return out


def _load_result_from_job(db_path: str, job_id: int) -> Any:
    con = sqlite3.connect(db_path)
    con.row_factory = sqlite3.Row
    try:
        row = con.execute("SELECT result FROM jobs WHERE id=?", (job_id,)).fetchone()
        if not row or not row["result"]:
            raise SystemExit(f"No result for job {job_id}")
        return json.loads(row["result"])
    finally:
        con.close()


def _load_result_from_input(input_path: str) -> Any:
    if input_path == "-":
        raw = sys.stdin.read()
    else:
        raw = Path(input_path).read_text(encoding="utf-8")
    if not raw.strip():
        raise SystemExit("Empty input JSON")
    return json.loads(raw)


def _pick_write_root(
    repo_root: Path, blueprint_id: Optional[str], explicit_root: Optional[str]
) -> Path:
    if explicit_root:
        return Path(explicit_root).resolve()
    if blueprint_id:
        return (repo_root / "blueprints" / blueprint_id / "generated").resolve()
    return repo_root.resolve()


def _rewrite_dest_rel(rel: Path, write_root: Path) -> Path:
    """
    If we're writing into a blueprint generated dir, and the source path starts
    with 'generated/', drop that prefix so:
      generated/services/api/app.py  ->  services/api/app.py
    This matches how you want blueprint layouts.
    """
    parts = rel.parts
    if write_root.name == "generated" and write_root.parent.name != "velu":
        # not reliable, keep simple
        return rel
    # Better: detect blueprint generated path explicitly
    if "blueprints" in write_root.parts and write_root.name == "generated":
        if parts and parts[0] == "generated":
            return Path(*parts[1:])
    return rel


def main() -> int:
    ap = argparse.ArgumentParser(
        description=(
            "Write files from a job result into the working tree.\n"
            "- Supports jobs.db (positional job_id) or JSON input (-i).\n"
            "- If --blueprint-id is set, default write root becomes blueprints/<id>/generated/.\n"
            "- If result has wrote[], will copy those on-disk files into the write root."
        )
    )
    ap.add_argument("job_id", nargs="?", type=int, help="Job id in jobs.db (legacy mode)")
    ap.add_argument("--db", default="data/jobs.db", help="Jobs DB path (legacy mode)")
    ap.add_argument("-i", "--input", default=None, help="JSON file path, or '-' for stdin")
    ap.add_argument("--root", default=None, help="Override write root")
    ap.add_argument(
        "--blueprint-id", default=None, help="Write into blueprints/<id>/generated by default"
    )
    args = ap.parse_args()

    if args.input is not None:
        payload = _load_result_from_input(args.input)
    elif args.job_id is not None:
        payload = _load_result_from_job(args.db, args.job_id)
    else:
        raise SystemExit("Provide either job_id OR --input/-i JSON file")

    blueprint_id = (
        args.blueprint_id.strip()
        if isinstance(args.blueprint_id, str) and args.blueprint_id.strip()
        else None
    )
    write_root = _pick_write_root(REPO_ROOT, blueprint_id, args.root)
    write_root.mkdir(parents=True, exist_ok=True)

    written: List[str] = []
    copied_from_wrote: List[str] = []

    for result in _iter_results(payload):
        # 1) apply returned files[]
        for f in _extract_files_list(result):
            rel = _safe_rel_path(f["path"])
            rel = _rewrite_dest_rel(rel, write_root)
            p = write_root / rel
            p.parent.mkdir(parents=True, exist_ok=True)
            p.write_text(f["content"], encoding="utf-8")
            written.append(str(p.relative_to(write_root)))

        # 2) if no files[], but wrote[] exists: copy from disk
        for wp in _extract_wrote_list(result):
            rel_src = _safe_rel_path(wp)
            src = (REPO_ROOT / rel_src).resolve()
            if not src.exists():
                continue

            rel_dst = _rewrite_dest_rel(rel_src, write_root)
            dst = (write_root / rel_dst).resolve()
            dst.parent.mkdir(parents=True, exist_ok=True)

            if src.is_dir():
                shutil.copytree(src, dst, dirs_exist_ok=True)
            else:
                shutil.copy2(src, dst)
            copied_from_wrote.append(str(dst.relative_to(write_root)))

    print("WRITE_ROOT:", str(write_root))
    if written:
        print("WROTE_FROM_FILES:", *written, sep="\n - ")
    if copied_from_wrote:
        print("COPIED_FROM_WROTE:", *copied_from_wrote, sep="\n - ")
    if not written and not copied_from_wrote:
        print("NO_OUTPUT: (no files[] and no valid wrote[] paths)")

    print(
        json.dumps(
            {
                "ok": True,
                "blueprint_id": blueprint_id,
                "written_files": len(written),
                "copied_paths": len(copied_from_wrote),
            },
            indent=2,
        )
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
