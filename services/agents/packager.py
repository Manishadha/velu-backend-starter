from __future__ import annotations

import json
import logging
import time
import zipfile
from pathlib import Path
from typing import Any, Dict, Iterable, Tuple

logger = logging.getLogger(__name__)

BASE_DIR = Path.cwd()
ARTIFACTS_DIR = BASE_DIR / "artifacts"

CLIENT_README_TEMPLATE_PATH = (
    Path(__file__).resolve().parents[2] / "templates" / "README_client_template.md"
)
CLIENT_README_NAME = "README_client.md"

README_PACKAGED_PREFIX = "# Packaged project: "

README_PACKAGED_BODY = (
    "\n\n"
    "This zip was generated by Velu's packager.\n\n"
    "It contains some or all of the following pieces, depending on what you asked Velu to build:\n"
    "- generated/              : generated FastAPI / API services and other code\n"
    "- generated/web/          : generated Next.js frontend (if present)\n"
    "- react_spa/              : Vite + React SPA (if present)\n"
    "- generated/services/node : Node/Express/NestJS API (if present)\n"
    "- mobile/react_native/    : React Native / Expo app (if present)\n"
    "- mobile/flutter/         : Flutter app (if present)\n"
    "- tests_app/              : small pytest suite for basic health checks\n"
    "- pyproject.toml / requirements.txt : Python project metadata\n"
    "- README.md               : this README\n\n"
    "This archive also includes:\n"
    "- artifacts/manifest.json : a machine-readable build manifest\n"
    "- SECURITY_REPORT.md      : security scan summary (if available)\n"
    "- run_local.sh / Makefile : one-command local runner\n\n"
)

DOCKERFILE_PACKAGED = """
FROM python:3.12-slim

WORKDIR /app

RUN apt-get update && apt-get install -y --no-install-recommends build-essential && rm -rf /var/lib/apt/lists/*

COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

COPY . /app

EXPOSE 8000
CMD ["uvicorn", "generated.services.api.app:app", "--host", "0.0.0.0", "--port", "8000"]
""".lstrip()

DOCKER_COMPOSE_PACKAGED = """
version: "3.9"

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile_packaged
    environment:
      - HOST=0.0.0.0
      - PORT=8000
    ports:
      - "8000:8000"

  web:
    image: node:20-alpine
    working_dir: /app
    volumes:
      - ./generated/web:/app
    command: sh -c "npm install && npm run dev -- --port 3000"
    ports:
      - "3000:3000"
    depends_on:
      - api
""".lstrip()

DEVELOPER_README_MD = """
# Developer guide for {module}

## Stack

- Backend: {backend}
- Frontend: {frontend}
- Database: {database}
- Plan tier: {plan_tier}
- Plugins: {plugins}

## Layout

- `generated/services/api`   – Python backend (FastAPI style)
- `generated/services/node`  – optional Node backend
- `generated/web`            – Next.js frontend
- `react_spa`                – React SPA
- `tests_app`                – small pytest suite for health checks

## Quick local run

- `./run_local.sh` (recommended)
- or `make run`

## Python backend

    python -m venv .venv
    source .venv/bin/activate
    pip install -r requirements.txt
    uvicorn generated.services.api.app:app --reload --port 8000

API base: http://localhost:8000

Useful endpoints:

- `/health`
- `/ready`
- `/docs` (OpenAPI UI, if enabled)

## Next.js frontend

    cd generated/web
    npm install
    npm run dev -- --port 3001

Frontend dev URL: http://localhost:3001

## Tests

    pytest -q
""".lstrip()

AUTH_EXTRA_DEV_SECTION = """
## Auth plugin

This project was generated with the **auth** plugin enabled.

The scaffolded backend includes a minimal `/auth` router:

- `POST /auth/register` – create a demo user (stored in memory).
- `POST /auth/login` – log in with email and password, returns a demo token payload.
- `GET /auth/me` – returns a placeholder current user.

If the Next.js frontend is used, there is also a simple login page at `/login`
that calls the `/auth/login` API using the `NEXT_PUBLIC_API_BASE_URL` setting.

In a real production deployment you should replace this demo logic with
proper password hashing, persistent storage, and robust session / token handling.
""".lstrip()

SECURITY_MD = """
# Security policy

This project was generated by Velu.

## Reporting a security issue

If you find a vulnerability or security issue in this project, please:

1. Do **not** share exploit details publicly.
2. Contact the maintainers directly (for example by email).
3. Provide as much detail as you can:
   - Steps to reproduce
   - Affected endpoints or components
   - Any logs or screenshots (if safe to share)

## Recommended hardening steps

- Run behind HTTPS only.
- Set strong secrets (JWT/session).
- Restrict database access (private network, least privilege).
- Turn on logging/monitoring.
- Regularly apply dependency updates.
""".lstrip()

ENVIRONMENT_VARIABLES_MD = """
# Environment variables

## Backend (FastAPI / API)

- `HOST` (default: `0.0.0.0`)
- `PORT` (default: `8000`)
- `ENV`  (local/staging/production)

If you use Postgres:
- `DATABASE_URL` (example: `postgresql://user:pass@localhost:5432/app_db`)
""".lstrip()

SUPPORT_AND_WARRANTY_MD = """
# Support and warranty

Generated by Velu.

If you run this project yourself:
- you own ops, backups, monitoring, security patching.

Provided "as is" unless you have a separate written agreement.
""".lstrip()

STUB_AI_ROUTE = """
from __future__ import annotations
from typing import Any, Dict, List
from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter(prefix="/v1/ai", tags=["ai"])

class ChatMessage(BaseModel):
    role: str
    content: str

class ChatRequest(BaseModel):
    messages: List[ChatMessage]

@router.post("/chat")
async def chat(req: ChatRequest) -> Dict[str, Any]:
    last = req.messages[-1].content if req.messages else ""
    return {"reply": last or "hello"}
""".lstrip()

STUB_I18N_ROUTE = """
from __future__ import annotations
from typing import Dict, List
from fastapi import APIRouter
from pydantic import BaseModel, Field

router = APIRouter(prefix="/v1/i18n", tags=["i18n"])

DEFAULT_LOCALES: List[str] = ["en"]

class ProductSpec(BaseModel):
    name: str = "Product"
    locales: List[str] = Field(default_factory=lambda: ["en"])

class MessagesRequest(BaseModel):
    product: ProductSpec

@router.get("/locales")
async def list_locales() -> Dict[str, List[str]]:
    return {"locales": DEFAULT_LOCALES}

@router.post("/messages")
async def generate_messages(payload: MessagesRequest) -> Dict[str, Dict[str, Dict[str, str]]]:
    messages: Dict[str, Dict[str, str]] = {}
    for loc in payload.product.locales:
        messages[loc] = {"app.title": payload.product.name, "app.tagline": "Generated by Velu"}
    return {"messages": messages}
""".lstrip()

SKIP_PACKAGED_PATHS = {
    Path("generated/services/api/routes/ai.py"),
    Path("generated/services/api/routes/i18n.py"),
}

def _workspace_from_payload(payload: Dict[str, Any], default_base: Path) -> Path:
    velu = payload.get("_velu")
    if isinstance(velu, dict):
        
        ws = velu.get("workspace")
        if isinstance(ws, str) and ws.strip():
            return Path(ws.strip())

        
        run_id = velu.get("run_id")
        if isinstance(run_id, str) and run_id.strip():
        
            return Path("/tmp") / "velu-workspace" / "local" / run_id.strip()

    return default_base


def _iter_project_files(base: Path) -> Iterable[Tuple[Path, Path]]:
    include_dirs = {"generated", "web", "react_spa", "mobile", "src", "tests", "artifacts"}

    skip_dir_names = {
        ".venv",
        "node_modules",
        ".next",
        "__pycache__",
        ".pytest_cache",
        ".git",
        "data",
        "tmp",          
    }


    exclude_prefixes = [
        Path("generated") / "product_catalog_web_1",
        Path("generated") / "product_catalog_web_2",
    ]

    for name in include_dirs:
        d = base / name
        if not d.exists():
            continue
        for path in d.rglob("*"):
            if not path.is_file():
                continue
            rel = path.relative_to(base)

            if rel in SKIP_PACKAGED_PATHS:
                continue
            if any(part in skip_dir_names for part in rel.parts):
                continue

            skip = False
            for prefix in exclude_prefixes:
                if rel.parts[: len(prefix.parts)] == prefix.parts:
                    skip = True
                    break
            if skip:
                continue

            yield path, rel

    for name in ("pyproject.toml", "requirements.txt", "requirements-dev.txt"):
        p = base / name
        if p.exists() and p.is_file():
            yield p, p.relative_to(base)

def _inject_app_server_files(zf: zipfile.ZipFile, zf_writestr) -> int:
    n = 0
    if zf_writestr("generated/services/app_server/__init__.py", ""):
        n += 1
    if zf_writestr(
        "generated/services/app_server/main.py",
        "from generated.services.api.app import app as _base\n"
        "def create_app():\n"
        "    return _base\n"
        "app = create_app()\n",
    ):
        n += 1
    return n

def _inject_node_backend_files(zf: zipfile.ZipFile, base_dir: Path) -> int:
    node_dir = base_dir / "generated" / "services" / "node"
    real_app = node_dir / "app.js"
    if real_app.exists():
        return 0

    node_pkg_json = """
{
  "name": "velu-node-api",
  "version": "1.0.0",
  "private": true,
  "scripts": { "dev": "node app.js" },
  "dependencies": { "express": "^4.18.2" }
}
""".lstrip()

    node_app_js = """
const express = require('express');
const app = express();
const port = process.env.PORT || 9000;

app.get('/health', (req, res) => { res.json({ ok: true, app: 'velu-node-api' }); });

app.listen(port, () => { console.log('Node API listening on ' + port); });
""".lstrip()

    zf.writestr("generated/services/node/package.json", node_pkg_json)
    zf.writestr("generated/services/node/app.js", node_app_js)
    zf.writestr("generated/services/node/package-lock.json", "{}\n")
    return 3

def _detect_stack(base: Path) -> Dict[str, bool]:
    return {
        "has_fastapi": (base / "generated" / "services" / "api").exists()
        or (base / "generated" / "services" / "app_server").exists(),
        "has_node": (base / "generated" / "services" / "node").exists(),
        "has_nextjs": (base / "generated" / "web").exists(),
        "has_react_spa": (base / "react_spa").exists(),
        "has_rn": (base / "mobile" / "react_native").exists(),
        "has_flutter": (base / "mobile" / "flutter").exists(),
    }

def _render_client_readme(
    module: str,
    base: Path,
    *,
    kind: str | None = None,
    backend: str | None = None,
    database: str | None = None,
    plan_tier: str = "starter",
) -> str:
    stack = _detect_stack(base)

    kind = (kind or "").strip().lower() or "app"
    backend = (backend or "").strip().lower() or "fastapi"
    database = (database or "").strip().lower() or "sqlite"
    plan_tier = (plan_tier or "starter").strip().lower()

    kind_label_map = {
        "website": "website",
        "web_app": "web application",
        "mobile_app": "mobile application",
        "dashboard": "dashboard application",
        "api_only": "backend API (no frontend)",
    }
    kind_label = kind_label_map.get(kind, "application")

    db_map = {
        "sqlite": "SQLite (file-based, simple for development)",
        "postgres": "PostgreSQL",
        "mysql": "MySQL / MariaDB",
        "mongodb": "MongoDB",
        "none": "No database configured",
    }
    db_label = db_map.get(database, database or "Database not specified")

    lines: list[str] = []
    title = module.strip() or "Your app"
    lines.append(f"# {title} – Quick start")
    lines.append("")
    lines.append("## What’s inside")
    lines.append(f"- Product type: **{kind_label}**")
    lines.append(f"- Backend: **{backend}**")
    lines.append(f"- Database: **{db_label}**")
    lines.append("")
    lines.append("## One-command local run")
    lines.append("")
    lines.append("```bash")
    lines.append("./run_local.sh")
    lines.append("```")
    lines.append("")
    lines.append("## Manual run (if you prefer)")
    lines.append("")
    lines.append("```bash")
    lines.append("python -m venv .venv")
    lines.append("source .venv/bin/activate")
    lines.append("pip install -r requirements.txt")
    lines.append("uvicorn generated.services.api.app:app --reload --port 8000")
    lines.append("```")
    if stack["has_nextjs"]:
        lines.append("")
        lines.append("```bash")
        lines.append("cd generated/web")
        lines.append("npm install")
        lines.append("npm run dev -- --port 3001")
        lines.append("```")
    lines.append("")
    lines.append("## Tests")
    lines.append("")
    lines.append("```bash")
    lines.append("pytest -q")
    lines.append("```")
    lines.append("")
    return "\n".join(lines)

def _inject_services_stubs(zf: zipfile.ZipFile) -> int:
    count = 0
    zf.writestr("services/__init__.py", "")
    count += 1
    zf.writestr("services/agents/__init__.py", "")
    count += 1
    zf.writestr("services/queue/__init__.py", "from __future__ import annotations\n")
    count += 1
    zf.writestr("services/llm/__init__.py", "")
    count += 1
    return count

def _inject_ai_i18n_routes(zf: zipfile.ZipFile) -> int:
    zf.writestr("generated/services/api/routes/ai.py", STUB_AI_ROUTE)
    zf.writestr("generated/services/api/routes/i18n.py", STUB_I18N_ROUTE)
    return 2

def _inject_tests_app(zf: zipfile.ZipFile) -> int:
    count = 0
    zf.writestr("pytest.ini", "[pytest]\ntestpaths = tests_app\n")
    count += 1
    zf.writestr("tests_app/__init__.py", "")
    count += 1
    zf.writestr(
        "tests_app/test_health.py",
        """
from fastapi.testclient import TestClient
from generated.services.api.app import app
client = TestClient(app)
def test_health_endpoint_ok():
    r = client.get("/health")
    assert r.status_code == 200
""".lstrip(),
    )
    count += 1
    return count

def _safe_json(obj: Any) -> str:
    try:
        return json.dumps(obj, ensure_ascii=False, indent=2)
    except Exception:
        return json.dumps({"error": "not_json_serializable"}, ensure_ascii=False, indent=2)

def _render_security_report(payload: Dict[str, Any]) -> str:
    
    if isinstance(payload.get("security_report"), str) and payload["security_report"].strip():
        return payload["security_report"].strip() + "\n"

    
    p = payload.get("security_report_path")
    if isinstance(p, str) and p.strip():
        fp = Path(p.strip())
        if fp.exists() and fp.is_file():
            try:
                return fp.read_text(encoding="utf-8", errors="ignore").strip() + "\n"
            except Exception:
                pass

    try:
        base_dir = _workspace_from_payload(payload, BASE_DIR)  
        candidate = Path(base_dir) / "artifacts" / "SECURITY_REPORT.md"
        if candidate.exists() and candidate.is_file():
            return candidate.read_text(encoding="utf-8", errors="ignore").strip() + "\n"
    except Exception:
        pass

    
    return (
        "# Security report\n\n"
        "No security scan report was embedded in this release bundle.\n\n"
        "If you ran a `security_scan` stage in Velu, configure it to pass one of:\n"
        "- `security_report` (markdown text)\n"
        "- `security_report_path` (path to a report file)\n\n"
        "Alternatively, ensure the scan writes to:\n"
        "- `<workspace>/artifacts/SECURITY_REPORT.md`\n\n"
        "Recommended minimum checks:\n"
        "- dependency audit (pip-audit / npm audit)\n"
        "- secret scan (gitleaks)\n"
        "- SAST baseline (semgrep)\n"
    )


def _render_run_local_sh() -> str:
    return (
        "#!/usr/bin/env bash\n"
        "set -euo pipefail\n\n"
        "echo \"[velu] local runner\"\n\n"
        "if [ -f requirements.txt ]; then\n"
        "  if [ ! -d .venv ]; then\n"
        "    python -m venv .venv\n"
        "  fi\n"
        "  source .venv/bin/activate\n"
        "  pip install -r requirements.txt\n"
        "fi\n\n"
        "if [ -d generated/web ]; then\n"
        "  (cd generated/web && (npm install) && echo \"[velu] nextjs deps ok\")\n"
        "fi\n\n"
        "echo \"[velu] running tests (optional)\"\n"
        "pytest -q || true\n\n"
        "echo \"[velu] starting api on :8000\"\n"
        "exec uvicorn generated.services.api.app:app --host 0.0.0.0 --port 8000\n"
    )

def _render_makefile() -> str:
    return (
        "run:\n"
        "\t./run_local.sh\n\n"
        "test:\n"
        "\tpytest -q\n"
    )

def _render_infra_env_example() -> str:
    return (
        "ENV=local\n"
        "HOST=0.0.0.0\n"
        "PORT=8000\n"
        "# DATABASE_URL=postgresql://user:pass@localhost:5432/app_db\n"
    )

def _render_infra_compose_local() -> str:
    return (
        "version: \"3.9\"\n"
        "services:\n"
        "  api:\n"
        "    build:\n"
        "      context: ..\n"
        "      dockerfile: Dockerfile_packaged\n"
        "    env_file:\n"
        "      - .env.example\n"
        "    ports:\n"
        "      - \"8000:8000\"\n"
    )

def handle(payload: Dict[str, Any]) -> Dict[str, Any]:
    payload = dict(payload or {})
    module = str(payload.get("module") or "app").strip() or "app"

    base_dir = _workspace_from_payload(payload, BASE_DIR).resolve()
    artifacts_dir = ARTIFACTS_DIR.resolve()
    artifacts_dir.mkdir(parents=True, exist_ok=True)

    kind = (payload.get("kind") or "").strip() or None
    backend = (payload.get("backend") or "").strip() or None
    database = (payload.get("database") or "").strip() or None
    plan_tier = (payload.get("plan_tier") or "starter").strip().lower()

    plugins_list = payload.get("plugins") or []
    plugins_set = {str(p).strip().lower() for p in plugins_list if str(p or "").strip()}

    product_spec = payload.get("product_spec")
    pipeline_info = payload.get("pipeline")
    job_meta = payload.get("_velu") if isinstance(payload.get("_velu"), dict) else {}

    zip_path = (artifacts_dir / f"{module}.zip").resolve()
    logger.info("packager: creating %s", zip_path)

    manifest: Dict[str, Any] = {
        "schema_version": 1,
        "created_at": int(time.time()),
        "module": module,
        "kind": kind or "app",
        "stack": {
            "backend": backend or "fastapi",
            "frontend": "nextjs",
            "database": database or "sqlite",
        },
        "plan_tier": plan_tier,
        "plugins": sorted(set(str(x) for x in plugins_list if str(x or "").strip())),
        "product_spec": product_spec if isinstance(product_spec, dict) else None,
        "pipeline": pipeline_info if isinstance(pipeline_info, dict) else None,
        "job": job_meta,
        "release": {
            "format": "zip",
            "includes": [
                "README.md",
                "README_client.md",
                "README_developer.md",
                "SECURITY_REPORT.md",
                "artifacts/manifest.json",
                "run_local.sh",
                "Makefile",
                "infra/.env.example",
                "infra/docker-compose.local.yml",
            ],
        },
    }

    with zipfile.ZipFile(zip_path, "w", compression=zipfile.ZIP_DEFLATED) as zf:
        seen: set[str] = set()
        count = 0

        def zf_writestr(name: str, data: str) -> bool:
            n = name.replace("\\", "/")
            if n in seen:
                return False
            zf.writestr(n, data)
            seen.add(n)
            return True

        def zf_write(path: Path, arcname: Path) -> bool:
            n = arcname.as_posix()
            if n in seen:
                return False
            zf.write(path, n)
            seen.add(n)
            return True

        readme_content = README_PACKAGED_PREFIX + module + "\n\n" + README_PACKAGED_BODY
        if zf_writestr("README_packaged.md", readme_content):
            count += 1
        if zf_writestr("README.md", readme_content):
            count += 1

        client_readme = _render_client_readme(
            module,
            base_dir,
            kind=kind,
            backend=backend,
            database=database,
            plan_tier=plan_tier,
        )
        if zf_writestr("README_client.md", client_readme):
            count += 1

        plugins_str = ", ".join(sorted(set(str(p) for p in plugins_list if str(p or "").strip()))) or "none"
        dev_readme = DEVELOPER_README_MD.format(
            module=module,
            backend=backend or "fastapi",
            frontend="nextjs",
            database=database or "sqlite",
            plan_tier=plan_tier,
            plugins=plugins_str,
        )
        if "auth" in plugins_set:
            dev_readme = dev_readme.rstrip() + "\n\n" + AUTH_EXTRA_DEV_SECTION
        if zf_writestr("README_developer.md", dev_readme):
            count += 1

        if plan_tier in {"pro", "enterprise"}:
            if zf_writestr("SECURITY.md", SECURITY_MD):
                count += 1

        if zf_writestr("Dockerfile_packaged", DOCKERFILE_PACKAGED):
            count += 1
        if zf_writestr("docker-compose.packaged.yml", DOCKER_COMPOSE_PACKAGED):
            count += 1
        if zf_writestr("ENVIRONMENT_VARIABLES.md", ENVIRONMENT_VARIABLES_MD):
            count += 1
        if zf_writestr("SUPPORT_AND_WARRANTY.md", SUPPORT_AND_WARRANTY_MD):
            count += 1

        if zf_writestr("run_local.sh", _render_run_local_sh()):
            count += 1
        if zf_writestr("Makefile", _render_makefile()):
            count += 1
        if zf_writestr("infra/.env.example", _render_infra_env_example()):
            count += 1
        if zf_writestr("infra/docker-compose.local.yml", _render_infra_compose_local()):
            count += 1

        if zf_writestr("SECURITY_REPORT.md", _render_security_report(payload)):
            count += 1

        if zf_writestr("artifacts/manifest.json", _safe_json(manifest)):
            count += 1

        count += _inject_app_server_files(zf, zf_writestr)
        count += _inject_node_backend_files(zf, base_dir)
        count += _inject_services_stubs(zf)
        count += _inject_ai_i18n_routes(zf)
        count += _inject_tests_app(zf)

        for path, arcname in _iter_project_files(base_dir):
            if zf_write(path, arcname):
                count += 1

    return {
        "ok": True,
        "agent": "packager",
        "module": module,
        "artifact_path": str(zip_path),
        "artifact_exists": zip_path.exists(),
        "file_count": count,
        "release": {"manifest_path": "artifacts/manifest.json", "security_report": "SECURITY_REPORT.md"},
    }
